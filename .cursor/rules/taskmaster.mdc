---
description: Comprehensive reference for Taskmaster MCP tools and CLI commands.
globs: **/*
alwaysApply: true
---
# Taskmaster Tool & Command Reference

This document provides a detailed reference for interacting with Taskmaster, covering both the recommended MCP tools, suitable for integrations like Cursor, and the corresponding `task-master` CLI commands, designed for direct user interaction or fallback.

**Note:** For interacting with Taskmaster programmatically or via integrated tools, using the **MCP tools is strongly recommended** due to better performance, structured data, and error handling. The CLI commands serve as a user-friendly alternative and fallback.

**Important:** Several MCP tools involve AI processing... The AI-powered tools include `parse_prd`, `analyze_project_complexity`, `update_subtask`, `update_task`, `update`, `expand_all`, `expand_task`, and `add_task`.

---

## Integration with Knowledge Graph Memory (KGM) for Enhanced Task Management

To enable continuous learning and improve the effectiveness of Taskmaster operations over time, interaction with a Knowledge Graph Memory (KGM) MCP server is crucial. The KGM allows the agent to store and retrieve learnings related to task management, project specifics, user preferences, and successful patterns.

**Core Principles for KGM Integration with Taskmaster:**

1.  **Purpose:** Augment Taskmaster operations by leveraging past experiences stored in the KGM. This includes improving AI-driven task generation, updates, expansions, and overall project planning.
2.  **What to Store (Taskmaster Context):**
    * **Task Structuring Patterns:** Effective task definitions, subtask breakdowns, and dependency structures resulting from `parse_prd`, `add_task`, or `expand_task`.
    * **AI Tool Effectiveness:** Successful prompt formulations for AI-powered Taskmaster tools (`parse_prd`, `add_task`, `update_task`, `expand_task`, etc.) and the quality of their outputs.
    * **Error/Issue Resolution:** Solutions to common issues encountered during task execution or Taskmaster operations, linked to specific tasks or projects.
    * **Project-Specific Information:**
        * Taskmaster configurations (e.g., preferred models via `models` tool) for a given project.
        * Typical PRD structures, common task types, or recurring dependency patterns observed within a project.
        * Learnings from `analyze_project_complexity` specific to a project.
    * **User Preferences:** Preferences regarding task granularity, AI model choices, PRD parsing details, or interaction styles when using Taskmaster tools.
3.  **When to Query KGM (Read Operations):**
    * **Before AI-Powered Operations:** Prior to using tools like `parse_prd`, `add_task`, `update_task`, `update`, `expand_task`, `expand_all`, or `analyze_project_complexity`, query the KGM for relevant patterns, successful prompts, user preferences, or project-specific data that could inform the tool's execution.
    * **During Planning & Structuring:** When defining new tasks, subtasks, or dependencies, check the KGM for similar historical examples or established best practices for the current project or task type.
    * **Upon Encountering Issues:** If a Taskmaster operation yields unexpected results or if issues arise during the execution of a managed task, query the KGM for similar past problems and their resolutions.
4.  **When to Store in KGM (Write Operations):**
    * **After Successful AI-Powered Operations:** If a tool like `parse_prd` or `expand_task` produces a particularly effective or novel output (e.g., a well-structured task list, an insightful task breakdown), store the input parameters and the successful outcome.
    * **Post-Task Completion/Modification:** After successfully completing, updating, or resolving issues with a task managed by Taskmaster, store relevant learnings (e.g., effective update strategies, solutions to blockers).
    * **User Feedback Incorporation:** If user feedback leads to a refined approach for using a Taskmaster tool or structuring tasks, this new approach should be stored.
    * **New Project Initialization:** Store basic project metadata and its association with Taskmaster usage.
5.  **Project Context:** Always strive to associate KGM entries with a specific "Project" entity. This allows for tailored learning and retrieval based on the current project context. If a learning is globally applicable, it can be stored as such.
6.  **Learning Signal:** If the KGM is queried for specific information that is not found, and that information is subsequently generated or discovered during the current operation, this newly acquired knowledge becomes a strong candidate for storage in the KGM.

---

## Initialization & Setup

### 1. Initialize Project (`init`)

* **MCP Tool:** `initialize_project`
* **CLI Command:** `task-master init [options]`
* **Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project.`
* **Key CLI Options:** (Details omitted for brevity)
* **Usage:** Run this once at the beginning of a new project.
* **MCP Variant Description:** `Set up the basic Taskmaster file structure and configuration in the current directory for a new project by running the 'task-master init' command.`
* **Key MCP Parameters/Options:** (Details omitted for brevity)
* **Usage:** Run this once at the beginning of a new project, typically via an integrated tool like Cursor. Operates on the current working directory of the MCP server.
* **Important:** Once complete, you *MUST* parse a prd in order to generate tasks. There will be no tasks files until then. The next step after initializing should be to create a PRD using the example PRD in scripts/example\_prd.txt.
* **KGM Integration:**
    * **Write:** Upon successful project initialization, create or link a "Project" entity in the KGM. Store basic project metadata (name, description from parameters) and the fact that Taskmaster is being used for this project. This contextualizes future KGM entries for this project.

### 2. Parse PRD (`parse_prd`)

* **MCP Tool:** `parse_prd`
* **CLI Command:** `task-master parse-prd [file] [options]`
* **Description:** `Parse a Product Requirements Document, PRD, or text file with Taskmaster to automatically generate an initial set of tasks in tasks.json.`
* **Key Parameters/Options:** (Details omitted for brevity)
* **Usage:** Useful for bootstrapping a project from an existing requirements document.
* **Notes:** Task Master will strictly adhere to any specific requirements mentioned in the PRD...
* **Important:** This MCP tool makes AI calls and can take up to a minute to complete...
* **KGM Integration:**
    * **Read:** Before parsing the PRD:
        * Query KGM for preferred PRD structures, keywords, or formatting for the current project type or user.
        * Check for common task generation patterns from PRDs that were successful in similar projects.
        * Retrieve previously successful `numTasks` settings or other `parse_prd` parameters for similar PRDs or projects.
    * **Write:** After successful parsing and user validation of the generated tasks:
        * Store the relationship between the PRD's key features/structure and the generated task hierarchy as a successful pattern in KGM, linked to the project.
        * If specific task definitions generated are notably effective, store them as examples.

---

## AI Model Configuration

### 2. Manage Models (`models`)
* **MCP Tool:** `models`
* **CLI Command:** `task-master models [options]`
* **Description:** `View the current AI model configuration or set specific models for different roles...`
* **Key MCP Parameters/Options:** (Details omitted for brevity)
* **Key CLI Options:** (Details omitted for brevity)
* **Usage (MCP/CLI):** (Details omitted for brevity)
* **Notes:** Configuration is stored in `.taskmasterconfig`...
* **API note:** API keys ...
* **Model costs:** ...
* **Warning:** DO NOT MANUALLY EDIT THE .taskmasterconfig FILE...
* **KGM Integration:**
    * **Read/Write:**
        * Store the user's selected model preferences (main, research, fallback) in the KGM, associated with the user's general preferences or specific project preferences.
        * When this tool is invoked to view or set models, query the KGM for existing preferences. If found, suggest them or use them as defaults if appropriate for the context.
        * Persist any changes made to model configuration into the KGM as the current preference.

---

## Task Listing & Viewing

(Sections 3, 4, 5: `get_tasks`, `next_task`, `get_task` - KGM integration primarily for learning about user access patterns, less direct impact on tool execution logic itself, so detailed annotation omitted for brevity unless specific learning goals are defined for *how* users view tasks.)

---

## Task Creation & Modification

### 6. Add Task (`add_task`)

* **MCP Tool:** `add_task`
* **CLI Command:** `task-master add-task [options]`
* **Description:** `Add a new task to Taskmaster by describing it; AI will structure it.`
* **Key Parameters/Options:** (Details omitted for brevity)
* **Usage:** Quickly add newly identified tasks during development.
* **Important:** This MCP tool makes AI calls and can take up to a minute to complete...
* **KGM Integration:**
    * **Read:** Before generating the task structure from the `prompt`:
        * Query KGM for similar task prompts and how they were successfully structured into tasks/subtasks in the past (for this project or generally).
        * Check KGM for project-specific task templates, common fields, or preferred priority/dependency patterns.
    * **Write:** After the task is added and (ideally) validated by the user:
        * If the AI's structuring of the task from the prompt was particularly effective, store the input `prompt` and the resulting task structure as a successful pattern in KGM.

### 7. Add Subtask (`add_subtask`)
(Primarily manual structuring, KGM less directly involved in AI generation here. KGM could store common subtask patterns if they emerge from manual additions over time.)

### 8. Update Tasks (`update`)

* **MCP Tool:** `update`
* **CLI Command:** `task-master update [options]`
* **Description:** `Update multiple upcoming tasks in Taskmaster based on new context or changes...`
* **Key Parameters/Options:** (Details omitted for brevity)
* **Usage:** Handle significant implementation changes...
* **Important:** This MCP tool makes AI calls and can take up to a minute to complete...
* **KGM Integration:**
    * **Read:** Before processing the `prompt` to update tasks:
        * Query KGM for similar update scenarios (e.g., "switching framework X to Y," "clarifying requirements for module Z") and identify effective prompt formulations or resulting task modifications from past instances, especially within the current project.
    * **Write:** After a successful `update` operation that effectively addresses the change:
        * Store the context of the change (e.g., key elements of the `prompt`, the range of tasks affected `from`, and the nature of the modifications) as a learned pattern for handling such bulk updates in KGM.

### 9. Update Task (`update_task`)

* **MCP Tool:** `update_task`
* **CLI Command:** `task-master update-task [options]`
* **Description:** `Modify a specific Taskmaster task or subtask by its ID, incorporating new information or changes.`
* **Key Parameters/Options:** (Details omitted for brevity)
* **Usage:** Refine a specific task based on new understanding or feedback...
* **Important:** This MCP tool makes AI calls and can take up to a minute to complete...
* **KGM Integration:**
    * **Read:** Similar to `update`, query KGM for analogous `prompt` content applied to individual tasks and what modifications were successful.
    * **Write:** If the update results in a significantly improved or clarified task, store the `prompt` and the effective changes in KGM as an example of good task refinement.

### 10. Update Subtask (`update_subtask`)

* **MCP Tool:** `update_subtask`
* **CLI Command:** `task-master update-subtask [options]`
* **Description:** `Append timestamped notes or details to a specific Taskmaster subtask...`
* **Key Parameters/Options:** (Details omitted for brevity)
* **Usage:** Add implementation notes... Before calling, review the subtask's current details to append only fresh insights...
* **Important:** This MCP tool makes AI calls and can take up to a minute to complete...
* **KGM Integration:**
    * **Read:** Query KGM for common types of information or note structures previously found useful to append to subtasks of a similar nature or within the current project.
    * **Write:** If the appended information (via `prompt`) proves particularly valuable for tracking progress or resolving issues, this pattern of information logging for subtasks could be noted in KGM.

### 11. Set Task Status (`set_task_status`)
(KGM could track frequency of status changes or typical task lifecycles if advanced analytics are desired, but direct KGM interaction for the tool itself is minimal.)

### 12. Remove Task (`remove_task`)
(KGM could note reasons for task removal if this data is captured, potentially informing future planning to avoid generating tasks that get removed.)

---

## Task Structure & Breakdown

### 13. Expand Task (`expand_task`)

* **MCP Tool:** `expand_task`
* **CLI Command:** `task-master expand [options]`
* **Description:** `Use Taskmaster's AI to break down a complex task into smaller, manageable subtasks...`
* **Key Parameters/Options:** (Details omitted for brevity)
* **Usage:** Generate a detailed implementation plan...
* **Important:** This MCP tool makes AI calls and can take up to a minute to complete...
* **KGM Integration:**
    * **Read:** Before breaking down the task:
        * Query KGM for how similarly complex tasks (by title, description, or project context) were effectively decomposed into subtasks in the past.
        * Check for preferred number of subtasks (`num`) for certain task types or user-defined complexity levels based on past successful expansions.
        * Retrieve any project-specific guidelines from KGM on task granularity.
    * **Write:** After a successful `expand_task` operation and user validation of the subtasks:
        * Store the parent task's characteristics (e.g., complexity, keywords) and the resulting subtask structure as a successful decomposition pattern in KGM.

### 14. Expand All Tasks (`expand_all`)
* **MCP Tool:** `expand_all`
* **CLI Command:** `task-master expand --all [options]`
* **Description:** `Tell Taskmaster to automatically expand all eligible pending/in-progress tasks...`
* **Key Parameters/Options:** (Details omitted for brevity)
* **Usage:** Useful after initial task generation or complexity analysis...
* **Important:** This MCP tool makes AI calls and can take up to a minute to complete...
* **KGM Integration:**
    * **Read:** Similar to `expand_task`, but applies generally learned patterns or project-wide preferences for task expansion across multiple tasks. Query KGM for these broader guidelines.
    * **Write:** If `expand_all` using a specific `prompt` or `num` setting yields consistently good results across many tasks, this general strategy can be stored in KGM.

(Sections 15, 16: `clear_subtasks`, `remove_subtask` - Less direct AI/KGM interaction for generation, more for record-keeping if desired.)

---

## Dependency Management

(Sections 17, 18, 19, 20: `add_dependency`, `remove_dependency`, `validate_dependencies`, `fix_dependencies` - KGM could store common dependency patterns or learn from `fix_dependencies` actions, but direct annotation for each tool is omitted for brevity. The general principle applies: if a recurring pattern or successful fix occurs, store it.)

---

## Analysis & Reporting

### 21. Analyze Project Complexity (`analyze_project_complexity`)

* **MCP Tool:** `analyze_project_complexity`
* **CLI Command:** `task-master analyze-complexity [options]`
* **Description:** `Have Taskmaster analyze your tasks to determine their complexity and suggest which ones need to be broken down further.`
* **Key Parameters/Options:** (Details omitted for brevity)
* **Usage:** Used before breaking down tasks...
* **Important:** This MCP tool makes AI calls and can take up to a minute to complete...
* **KGM Integration:**
    * **Read:**
        * Query KGM for typical complexity scores, thresholds, or common expansion needs for similar projects or task types. This can help calibrate the analysis or provide context for interpreting its results.
        * Check for user or project-specific preferences regarding complexity thresholds stored in KGM.
    * **Write:**
        * Store insights from the complexity report if they lead to significant, successful refactoring of the task plan (e.g., "Tasks involving 'X' in 'Project Y' consistently score high and benefit from expansion based on threshold Z"). This helps refine future complexity analyses for the project.

### 22. View Complexity Report (`complexity_report`)
(Primarily a display tool; KGM interaction is through `analyze_project_complexity`.)

---

## File Management

### 23. Generate Task Files (`generate`)
(Utility tool; KGM interaction is indirect via the task data it processes.)

---

## Environment Variables Configuration (Updated)
(No direct KGM integration for environment variables themselves, but model choices configured here are subject to KGM storage as per the `models` tool section.)

---

For details on how these commands fit into the development process, see the @Development Workflow Guide.